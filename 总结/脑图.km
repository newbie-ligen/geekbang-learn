{"root":{"data":{"id":"18427e121e62","created":1637495419,"text":"训练营"},"children":[{"data":{"id":"cfvfoqtpjcg0","created":1637495437146,"text":"jvm","layout_mind_offset":{"x":-139,"y":-609},"expandState":"expand"},"children":[{"data":{"id":"cfvfwed8bbs0","created":1637496036941,"text":"jvm基础知识","layout_right_offset":{"x":107,"y":-1}},"children":[{"data":{"id":"cg1f41b5rlk0","created":1638103174061,"text":"Java 是一种面向对象、静态类型、编译执行，\n有 VM/GC 和运行时、跨平台的高级语言。","layout_right_offset":{"x":-7,"y":-17}},"children":[]}]},{"data":{"id":"cfvfwp36hs80","created":1637496060278,"text":"Java 字节码技术","layout_right_offset":{"x":106,"y":-11},"expandState":"expand"},"children":[{"data":{"id":"cg1f4xfc5oo0","created":1638103243971,"text":"指令四大类"},"children":[{"data":{"id":"cg1f7h0mk3s0","created":1638103443345,"text":"1. 栈操作指令，包括与局部变量交互的指令"},"children":[]},{"data":{"id":"cg1f7kmeobs0","created":1638103451193,"text":"2. 程序流程控制指令"},"children":[]},{"data":{"id":"cg1f7nlg0ww0","created":1638103457665,"text":"3. 对象操作指令，包括方法调用指令"},"children":[]},{"data":{"id":"cg1f7qbpjko0","created":1638103463607,"text":"4. 算术运算以及类型转换指令"},"children":[]}]},{"data":{"id":"cg1f5q997xk0","created":1638103306730,"text":"什么是字节码？"},"children":[{"data":{"id":"cg1f6a5favc0","created":1638103350034,"text":"Java bytecode 由单字节（byte）的指令组成，理论上最多支持 256 个操作码（opcode）。\n实际上 Java 只使用了200左右的操作码， 还有一些操作码则保留给调试操作。"},"children":[]}]},{"data":{"id":"cg1f8y770jc0","created":1638103559112,"text":"字节码的运行时结构"},"children":[{"data":{"id":"cg1f91n75y80","created":1638103566610,"text":"JVM 是一台基于栈的计算机器。"},"children":[]},{"data":{"id":"cg1f9doo12o0","created":1638103592820,"text":"每个线程都有一个独属于自己的线程栈（JVM Stack），用于存储\n栈帧（Frame）。"},"children":[]},{"data":{"id":"cg1f9lgtjqw0","created":1638103609760,"text":"每一次方法调用、JVM 都会自动创建一个栈帧。"},"children":[]},{"data":{"id":"cg1f9ojdyqg0","created":1638103616446,"text":"栈帧由操作数栈、 局部变量数组以及一个 Class 引用组成。"},"children":[]},{"data":{"id":"cg1f9sjva740","created":1638103625182,"text":"Class 引用指向当前方法在运行时常量池中对应的 Class。"},"children":[]}]}]},{"data":{"id":"cfvfwumvm4g0","created":1637496072353,"text":"JVM 类加载","layout_right_offset":{"x":116,"y":-19}},"children":[{"data":{"id":"cg1fgljwl8o0","created":1638104158496,"text":"类的生命周期"},"children":[{"data":{"id":"cg1fmqqyxgg0","created":1638104639992,"text":"加载（Loading）：找 Class 文件"},"children":[]},{"data":{"id":"cg1fmvcpirk0","created":1638104650013,"text":"连接"},"children":[{"data":{"id":"cg1fn4era480","created":1638104669728,"text":"验证（Verification）：验证格式、依赖"},"children":[]},{"data":{"id":"cg1fn8h8oyo0","created":1638104678586,"text":"准备（Preparation）：静态字段、方法表"},"children":[]},{"data":{"id":"cg1fnc6z43s0","created":1638104686672,"text":"解析（Resolution）：符号解析为引用"},"children":[]}]},{"data":{"id":"cg1fngo9f7k0","created":1638104696424,"text":"初始化（Initialization）：构造器、静态变\n量赋值、静态代码块"},"children":[]},{"data":{"id":"cg1fnkjdtx40","created":1638104704837,"text":"使用（Using）"},"children":[]},{"data":{"id":"cg1fnng07uo0","created":1638104711163,"text":"卸载（Unloading）"},"children":[]}]},{"data":{"id":"cg1fnv4envc0","created":1638104727876,"text":"类的加载时机"},"children":[{"data":{"id":"cg1fo5n733k0","created":1638104750779,"text":"当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main 方法所在的类；"},"children":[]},{"data":{"id":"cg1fomw7gk00","created":1638104788330,"text":"当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是 new 一\n个类的时候要初始化；"},"children":[]},{"data":{"id":"cg1foy7ajjs0","created":1638104812945,"text":"当遇到调用静态方法的指令时，初始化该静态方法所在的类；"},"children":[]},{"data":{"id":"cg1fp1sxuao0","created":1638104820784,"text":"当遇到访问静态字段的指令时，初始化该静态字段所在的类；"},"children":[]},{"data":{"id":"cg1fparbbfk0","created":1638104840277,"text":"子类的初始化会触发父类的初始化；"},"children":[]},{"data":{"id":"cg1fpf1uvkw0","created":1638104849621,"text":"如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，\n会触发该接口的初始化；"},"children":[]},{"data":{"id":"cg1fpiy0jjc0","created":1638104858096,"text":"使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用要\n么是已经有实例了，要么是静态方法，都需要初始化；"},"children":[]},{"data":{"id":"cg1fpmfyfrk0","created":1638104865711,"text":"当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。"},"children":[]}]},{"data":{"id":"cg1fqjwjbow0","created":1638104938548,"text":"类加载器"},"children":[{"data":{"id":"cg1fqq97zj40","created":1638104952375,"text":"启动类加载器（BootstrapClassLoader）"},"children":[]},{"data":{"id":"cg1fqsp2muo0","created":1638104957687,"text":"扩展类加载器（ExtClassLoader）"},"children":[]},{"data":{"id":"cg1fqvpr5880","created":1638104964259,"text":"应用类加载器（AppClassLoader）"},"children":[]},{"data":{"id":"cg1fqxq2bcg0","created":1638104968631,"text":"特点"},"children":[{"data":{"id":"cg1fr23zwuo0","created":1638104978181,"text":"双亲委托"},"children":[]},{"data":{"id":"cg1fr4sqqj40","created":1638104984031,"text":"负责依赖"},"children":[]},{"data":{"id":"cg1fr7cyp680","created":1638104989607,"text":"缓存加载"},"children":[]}]},{"data":{"id":"cg1frnk1uso0","created":1638105024864,"text":"添加引用类的几种方式"},"children":[{"data":{"id":"cg1frrdiwdc0","created":1638105033176,"text":"1、放到 JDK 的 lib/ext 下，或者 -Djava.ext.dirs"},"children":[]},{"data":{"id":"cg1frurjm1s0","created":1638105040554,"text":"2、 java-cp/classpath 或者 class 文件放到当前路径"},"children":[]},{"data":{"id":"cg1frytcd600","created":1638105049370,"text":"3、自定义 ClassLoader 加载"},"children":[]},{"data":{"id":"cg1fs16c7io0","created":1638105054510,"text":"4、拿到当前执行类的 ClassLoader，反射调用 addUrl 方法添加 Jar 或路径（JDK9 无效）"},"children":[]}]}]}]},{"data":{"id":"cfvfx159axs0","created":1637496086525,"text":"JVM 内存模型","layout_right_offset":{"x":107,"y":-24}},"children":[{"data":{"id":"cg1gdnum9q80","created":1638106749514,"text":"JVM 内存结构"},"children":[{"data":{"id":"cg1gf3shh2w0","created":1638106862578,"text":"对象分配","expandState":"expand"},"children":[{"data":{"id":"cg1gdt3p7340","created":1638106760947,"text":"如果是原生数据类型的局部变量，\n那么它的内容就全部保留在线程栈\n上。"},"children":[]},{"data":{"id":"cg1gdy7zsbk0","created":1638106772091,"text":"如果是对象引用，则栈中的局部变\n量槽位中保存着对象的引用地址，\n而实际的对象内容保存在堆中。"},"children":[]},{"data":{"id":"cg1ge2pi23k0","created":1638106781857,"text":"对象的成员变量与对象本身一起存\n储在堆上, 不管成员变量的类型是\n原生数值，还是对象引用。"},"children":[]},{"data":{"id":"cg1ge67grrs0","created":1638106789473,"text":"类的静态变量则和类定义一样都保\n存在堆中。"},"children":[]}]},{"data":{"id":"cg1gfef1ttc0","created":1638106885710,"text":"栈","expandState":"expand"},"children":[{"data":{"id":"cg1gfm90gs80","created":1638106902760,"text":"每启动一个线程，JVM 就会在栈空间栈分\n配对应的 线程栈, 比如 1MB 的空间（-\nXss1m）。"},"children":[]},{"data":{"id":"cg1gfthm5m80","created":1638106918517,"text":"线程栈也叫做 Java 方法栈。 如果使用了\nJNI 方法，则会分配一个单独的本地方法栈\n(Native Stack)。"},"children":[]},{"data":{"id":"cg1ggger5ig0","created":1638106968410,"text":"线程执行过程中，一般会有多个方法组成调\n用栈（Stack Trace）, 比如 A 调用 B，B\n调用 C…每执行到一个方法，就会创建对应\n的 栈帧（Frame）。"},"children":[]},{"data":{"id":"cg1ggsrtyeo0","created":1638106995322,"text":"栈帧是一个逻辑上的概念，具体的大小在\n一个方法编写完成后基本上就能确定。"},"children":[]},{"data":{"id":"cg1gkwk6uqw0","created":1638107317024,"text":"栈帧是一个逻辑上的概念，具体的大小在\n一个方法编写完成后基本上就能确定"},"children":[]},{"data":{"id":"cg1gl1uh2rc0","created":1638107328530,"text":"比如返回值需要有一个空间存放，每个局\n部变量都需要对应的地址空间，此外还有\n给指令使用的操作数栈，以及 class 指针\n（标识这个栈帧对应的是哪个类的方法, 指\n向非堆里面的 Class 对象）。","layout_right_offset":{"x":-6,"y":-8}},"children":[]}]},{"data":{"id":"cg1gmjl0ra00","created":1638107445504,"text":"堆和非堆","layout_right_offset":{"x":1,"y":23}},"children":[{"data":{"id":"cg1gmza1bww0","created":1638107479669,"text":"堆"},"children":[{"data":{"id":"cg1gmwzb1k80","created":1638107474666,"text":"堆内存是所有线程共用的内存空间，JVM 将\nHeap 内存分为年轻代（Young generation）和 老年代（Old generation, 也叫 Tenured）两部分。"},"children":[]},{"data":{"id":"cg1gn5fu7dk0","created":1638107493080,"text":"年轻代还划分为 3 个内存池，新生代（Eden\nspace）和存活区（Survivor space）, 在大部分\nGC 算法中有 2 个存活区（S0, S1），在我们可\n以观察到的任何时刻，S0 和 S1 总有一个是空的, 但一般较小，也不浪费多少空间。","layout_right_offset":{"x":9,"y":19}},"children":[]}]},{"data":{"id":"cg1gn931weg0","created":1638107501014,"text":"非堆","expandState":"expand"},"children":[{"data":{"id":"cg1gnf6p6s00","created":1638107514296,"text":"Non-Heap 本质上还是 Heap，只是一般不归 GC\n管理，里面划分为 3 个内存池。"},"children":[]},{"data":{"id":"cg1gnjq58bk0","created":1638107524178,"text":"Metaspace, 以前叫持久代（永久代, Permanent\ngeneration）, Java8 换了个名字叫 Metaspace。"},"children":[]},{"data":{"id":"cg1gnnftw9s0","created":1638107532262,"text":"CCS, Compressed Class Space, 存放 class 信\n息的，和 Metaspace 有交叉。"},"children":[]},{"data":{"id":"cg1gnqptg3k0","created":1638107539396,"text":"Code Cache存放 JIT 编译器编译后的本地机器代\n码。"},"children":[]}]}]}]}]},{"data":{"id":"cfvfx6o9y0w0","created":1637496098559,"text":"JVM 启动参数","layout_right_offset":{"x":102,"y":-17}},"children":[]},{"data":{"id":"cfvfxt7lyc00","created":1637496147617,"text":"jvm内置命令行工具","layout_right_offset":{"x":108,"y":-27}},"children":[]},{"data":{"id":"cfvfy68k5lk0","created":1637496175973,"text":"JDK 内置图形化工具","layout_right_offset":{"x":115,"y":-28}},"children":[]},{"data":{"id":"cfvfyau3x4o0","created":1637496185983,"text":"GC","layout_right_offset":{"x":123,"y":-38}},"children":[]},{"data":{"id":"cfvg05whnm80","created":1637496331971,"text":"JVM调优","layout_right_offset":{"x":127,"y":-48}},"children":[]}]},{"data":{"id":"cfvfozxkkew0","created":1637495456970,"text":"NIO","layout_mind_offset":{"x":194,"y":-119},"expandState":"expand"},"children":[{"data":{"id":"cfvg1srvukw0","created":1637496460123,"text":"java Socket编程","layout_right_offset":{"x":14,"y":16}},"children":[]},{"data":{"id":"cfvg2072mw80","created":1637496476279,"text":"IO","layout_right_offset":{"x":35,"y":12}},"children":[]},{"data":{"id":"cfvg27ct4e00","created":1637496491863,"text":"Netty ","layout_right_offset":{"x":20,"y":-20}},"children":[{"data":{"id":"cfvg3u7rx9s0","created":1637496619989,"text":"Netty高性能"},"children":[]},{"data":{"id":"cfvg3uz1pm80","created":1637496621638,"text":"Netty 网络程序优化"},"children":[]},{"data":{"id":"cfvg3vy6ujk0","created":1637496623763,"text":"API 网关"},"children":[]}]}]},{"data":{"id":"cfvfp9gt1680","created":1637495477724,"text":"并发编程","layout_mind_offset":{"x":-801,"y":-490},"expandState":"expand"},"children":[{"data":{"id":"cfvg5bbe6sw0","created":1637496735577,"text":"多线程基础","layout_left_offset":{"x":-272,"y":6}},"children":[{"data":{"id":"cg1buz2uda00","created":1638094000598,"text":"为什么会有多线程","layout_left_offset":{"x":-330,"y":-17}},"children":[{"data":{"id":"cg1bv9kumn40","created":1638094023454,"text":"摩尔定律失效","layout_left_offset":{"x":-337,"y":-10}},"children":[]},{"data":{"id":"cg1bvdjyhn40","created":1638094032107,"text":"多核+分布式时代的来临","layout_left_offset":{"x":-362,"y":-10}},"children":[]}]},{"data":{"id":"cg1bw1wl6ow0","created":1638094085114,"text":"线程和进程","layout_left_offset":{"x":-290,"y":-26}},"children":[{"data":{"id":"cg1bxphl4q00","created":1638094214814,"text":"线程是进程的基本执行单元，一个进程的所有任务都在线程中执行；进程要想执行任务，必须得有线程","layout_left_offset":{"x":-782.0000083595514,"y":-15}},"children":[]},{"data":{"id":"cg1bzekyzuo0","created":1638094347802,"text":"1同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间；\n2同一进程内的线程共享本进程的资源，而进程间的资源是独立的。","layout_left_offset":{"x":-650.9999961107969,"y":-22}},"children":[]}]}]},{"data":{"id":"cfvg5cozzhc0","created":1637496738577,"text":"Java 多线程","layout_left_offset":{"x":-364,"y":-35}},"children":[{"data":{"id":"cg1c0l5hfxc0","created":1638094440467,"text":"sleep和wait的区别","layout_left_offset":{"x":-303,"y":-31}},"children":[{"data":{"id":"cg1c0v86lu80","created":1638094462398,"text":"Thread.sleep: 释放 CPU","layout_left_offset":{"x":-388,"y":4}},"children":[]},{"data":{"id":"cg1c11c7hpc0","created":1638094475702,"text":"Object#wait : 释放对象锁","layout_left_offset":{"x":-375,"y":-2}},"children":[]}]},{"data":{"id":"cg1c1phlwxk0","created":1638094528272,"text":"线程的状态","layout_left_offset":{"x":-300,"y":-21}},"children":[{"data":{"id":"cg1c203htj40","created":1638094551363,"text":"初始NEW","layout_left_offset":{"x":-262,"y":-21}},"children":[]},{"data":{"id":"cg1c26m8cgw0","created":1638094565557,"text":"运行RUNNABLE/RUNNING/READY","layout_left_offset":{"x":-404,"y":-31}},"children":[]},{"data":{"id":"cg1c4bd056o0","created":1638094732611,"text":"等待WAITING","layout_left_offset":{"x":-281,"y":-39}},"children":[]},{"data":{"id":"cg1c4ovqyi80","created":1638094762042,"text":"超时TIME_WAITING","layout_left_offset":{"x":-319,"y":-41}},"children":[]},{"data":{"id":"cg1c4w89unk0","created":1638094778037,"text":"阻塞BLOCKED","layout_left_offset":{"x":-279,"y":-50}},"children":[]},{"data":{"id":"cg1c5b425ew0","created":1638094810434,"text":"终止TERMINATED","layout_left_offset":{"x":-288,"y":-56}},"children":[]}]},{"data":{"id":"cg1cytexue80","created":1638097122835,"text":"Callable和runnable区别","layout_left_offset":{"x":-308,"y":-96}},"children":[{"data":{"id":"cg1czk0j4zk0","created":1638097180737,"text":" Runnable#run()没有返回值\nCallable#call()方法有返回值","layout_left_offset":{"x":-462,"y":9}},"children":[]}]}]},{"data":{"id":"cfvg5djdbqo0","created":1637496740413,"text":"线程安全","layout_left_offset":{"x":-355,"y":-74}},"children":[{"data":{"id":"cg1c69pmldk0","created":1638094885749,"text":"多线程遇到的问题","layout_left_offset":{"x":-270,"y":-28}},"children":[{"data":{"id":"cg1c6kurqeg0","created":1638094910004,"text":"多个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。\n导致竞态条件发生的代码区称作临界区。\n不进行恰当的控制，会导致线程安全问题。","layout_left_offset":{"x":-673,"y":0}},"children":[]}]},{"data":{"id":"cg1c6qejziw0","created":1638094922085,"text":"并发相关的性质","layout_left_offset":{"x":-254,"y":8}},"children":[{"data":{"id":"cg1c6zs2ofs0","created":1638094942493,"text":"原子性","layout_left_offset":{"x":-284,"y":-29}},"children":[{"data":{"id":"cg1c795owww0","created":1638094962908,"text":"对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，\n要么不执行。","layout_left_offset":{"x":-672,"y":-10}},"children":[]},{"data":{"id":"cg1c8o5cfvk0","created":1638095073903,"text":"volatile 并不能保证原子性。","layout_left_offset":{"x":-339,"y":-11}},"children":[]}]},{"data":{"id":"cg1c7gpnla80","created":1638094979352,"text":"可见性","layout_left_offset":{"x":-279,"y":-22}},"children":[{"data":{"id":"cg1c80i05ww0","created":1638095022425,"text":"对于可见性，Java 提供了 volatile 关键字来保证可见性。","layout_left_offset":{"x":-496,"y":-19}},"children":[]},{"data":{"id":"cg1c84mjv7s0","created":1638095031407,"text":"当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要\n读取时，它会去内存中读取新值","layout_left_offset":{"x":-692.0000020861626,"y":-12}},"children":[]},{"data":{"id":"cg1c89gzlio0","created":1638095041955,"text":"另外，通过 synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻\n只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中","layout_left_offset":{"x":-679,"y":-6}},"children":[]}]},{"data":{"id":"cg1c8tu832w0","created":1638095086291,"text":"有序性","layout_left_offset":{"x":-281,"y":-33}},"children":[{"data":{"id":"cg1c9dg2v2o0","created":1638095128971,"text":"Java 允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影\n响到多线程并发执行的正确性。可以通过 volatile 关键字来保证一定的“有序性”（synchronized 和 Lock\n也可以）","layout_left_offset":{"x":-752,"y":11}},"children":[]}]},{"data":{"id":"cg1ca4l3km80","created":1638095188048,"text":"happens-before 原则","layout_left_offset":{"x":-344,"y":-24}},"children":[{"data":{"id":"cg1caaluwc00","created":1638095201154,"text":"程序次序规则：一个线程内，按照代码先后顺序","layout_left_offset":{"x":-613,"y":-14}},"children":[]},{"data":{"id":"cg1caesfl940","created":1638095210259,"text":"锁定规则：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作","layout_left_offset":{"x":-715,"y":-22}},"children":[]},{"data":{"id":"cg1cakga32g0","created":1638095222585,"text":"Volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作","layout_left_offset":{"x":-732,"y":-31}},"children":[]},{"data":{"id":"cg1cavene740","created":1638095246431,"text":"传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出 A 先于 C","layout_left_offset":{"x":-823,"y":-41}},"children":[]},{"data":{"id":"cg1cb13gdn40","created":1638095258815,"text":"线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每个一个动作","layout_left_offset":{"x":-718,"y":-46}},"children":[]},{"data":{"id":"cg1cb9rtbxc0","created":1638095277702,"text":"线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生","layout_left_offset":{"x":-853,"y":-53}},"children":[]},{"data":{"id":"cg1cbi5z2z40","created":1638095295972,"text":"线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join() 方法结束、\nThread.isAlive() 的返回值手段检测到线程已经终止执行","layout_left_offset":{"x":-845,"y":-62}},"children":[]},{"data":{"id":"cg1cbr1g9g80","created":1638095315290,"text":"对象终结规则：一个对象的初始化完成先行发生于他的 finalize() 方法的开始","layout_left_offset":{"x":-686,"y":-63}},"children":[]}]}]},{"data":{"id":"cg1cc9cqya00","created":1638095355155,"text":"synchronized 的实现","layout_left_offset":{"x":-454,"y":-100}},"children":[{"data":{"id":"cg1ccfxyfkw0","created":1638095369498,"text":"使用对象头标记字(Object monitor)","layout_left_offset":{"x":-529,"y":4}},"children":[]},{"data":{"id":"cg1cckeyz200","created":1638095379234,"text":"Synchronized 方法优化","layout_left_offset":{"x":-551,"y":2}},"children":[]},{"data":{"id":"cg1cco3e66g0","created":1638095387241,"text":" 偏向锁: BiaseLock","layout_left_offset":{"x":-569,"y":3}},"children":[]},{"data":{"id":"cg1d4jx1nls0","created":1638097572347,"text":"synchronized 方式的问题","layout_left_offset":{"x":-768,"y":13}},"children":[{"data":{"id":"cg1d4xwkrkw0","created":1638097602793,"text":"1、同步块的阻塞无法中断（不能 Interruptibly）\n2、同步块的阻塞无法控制超时（无法自动解锁）\n3、同步块无法异步处理锁（即不能立即知道是否可以拿到锁）\n4、同步块无法根据条件灵活的加锁解锁（即只能跟同步块范围一致）","layout_left_offset":{"x":-594,"y":-27}},"children":[]}]}]},{"data":{"id":"cg1cd1ybvo00","created":1638095417410,"text":"volatile","layout_left_offset":{"x":-407,"y":-117}},"children":[{"data":{"id":"cg1cd9zwvg00","created":1638095434920,"text":"每次读取都强制从主内存刷数据","layout_left_offset":{"x":-362,"y":-10}},"children":[]},{"data":{"id":"cg1cdfvsprs0","created":1638095447732,"text":"适用场景： 单个线程写；多个线程读","layout_left_offset":{"x":-403,"y":-13}},"children":[]},{"data":{"id":"cg1cdm2zclk0","created":1638095461227,"text":"原则： 能不用就不用，不确定的时候也不用","layout_left_offset":{"x":-419,"y":-20}},"children":[]},{"data":{"id":"cg1cdpr5wio0","created":1638095469219,"text":"替代方案： Atomic 原子操作类","layout_left_offset":{"x":-423,"y":-27}},"children":[]}]},{"data":{"id":"cg1cf47k8vc0","created":1638095579050,"text":"final","layout_left_offset":{"x":-430,"y":-120},"expandState":"expand"},"children":[{"data":{"id":"cg1cfcz1gps0","created":1638095598126,"text":"final class XXX 不允许继承","layout_left_offset":{"x":-278,"y":-25}},"children":[]},{"data":{"id":"cg1cfjis1gg0","created":1638095612380,"text":"final 方法 不允许 Override","layout_left_offset":{"x":-308,"y":-32}},"children":[]},{"data":{"id":"cg1cfpe54c80","created":1638095625160,"text":"final 局部变量 不允许修改","layout_left_offset":{"x":-315,"y":-34}},"children":[]},{"data":{"id":"cg1cfxirs740","created":1638095642855,"text":"final 实例属性 \n 构造函数/初始化块/之后不允许变更；\n只能赋值一次\n安全发布: 构造函数结束返回时，final 域最新的值被保\n证对其他线程可见","layout_left_offset":{"x":-466,"y":-41}},"children":[]},{"data":{"id":"cg1cgnil51s0","created":1638095699440,"text":"final static 属性 静态块执行后不允许变更；\n只能赋值一次","layout_left_offset":{"x":-442,"y":-48}},"children":[]},{"data":{"id":"cg1cgw1qr5k0","created":1638095718012,"text":"Java 里的常量替换。写代码最大化用 final 是个好习惯。","layout_left_offset":{"x":-477,"y":-55}},"children":[]}]}]},{"data":{"id":"cfvg5t2rgv40","created":1637496774237,"text":"线程池","layout_left_offset":{"x":-780,"y":-216}},"children":[{"data":{"id":"cg1ch59e99s0","created":1638095738066,"text":"相关类和接口","layout_left_offset":{"x":-283,"y":-22}},"children":[{"data":{"id":"cg1chhr25o00","created":1638095765256,"text":"Excutor: 执行者，顶层接口","layout_left_offset":{"x":-405,"y":-25}},"children":[{"data":{"id":"cg1cjhx9t680","created":1638095922360,"text":"线程池从功能上看，就是一个任务执行器","layout_left_offset":{"x":-497.0000003874302,"y":-15}},"children":[]},{"data":{"id":"cg1cjnfh5h40","created":1638095934344,"text":"submit和execute的区别","layout_left_offset":{"x":-442,"y":-17}},"children":[{"data":{"id":"cg1cjzavxuw0","created":1638095960188,"text":"submit 方法 -> 有返回值，用 Future 封装\nexecute 方法 -> 无返回值","layout_left_offset":{"x":-493,"y":-6}},"children":[]},{"data":{"id":"cg1ck49qjc80","created":1638095971002,"text":"submit 方法还异常可以在主线程中 get 捕获到\nexecute 方法执行任务是捕捉不到异常的","layout_left_offset":{"x":-507,"y":-3}},"children":[]}]}]},{"data":{"id":"cg1ciiipw9k0","created":1638095845292,"text":"ExcutorService: 接口 API","layout_left_offset":{"x":-404,"y":-30}},"children":[{"data":{"id":"cg1ckik4o540","created":1638096002106,"text":"shutdown()：停止接收新任务，原来的任务继续执行","layout_left_offset":{"x":-600,"y":-16}},"children":[]},{"data":{"id":"cg1ckohevrc0","created":1638096015002,"text":"shutdownNow()：停止接收新任务，原来的任务停止执行","layout_left_offset":{"x":-625,"y":-21}},"children":[]},{"data":{"id":"cg1cku5pd280","created":1638096027355,"text":"boolean awaitTermination(timeOut, unit)：阻塞当前线程，返回是否线程都执行完","layout_left_offset":{"x":-749,"y":-28}},"children":[]}]},{"data":{"id":"cg1cin1pfts0","created":1638095855147,"text":"ThreadFactory: 线程工厂","layout_left_offset":{"x":-415,"y":-39}},"children":[]},{"data":{"id":"cg1cirk8ysw0","created":1638095864976,"text":"ThreadPoolExecutor","layout_left_offset":{"x":-415,"y":-47}},"children":[{"data":{"id":"cg1cle0e0m00","created":1638096070569,"text":"ThreadPoolExecutor 提交任务逻辑","layout_left_offset":{"x":-460,"y":-1}},"children":[{"data":{"id":"cg1cll4t68o0","created":1638096086074,"text":"1. 判断 corePoolSize 【创建】\n2. 加入 workQueue\n3. 判断 maximumPoolSize 【创建】\n4. 执行拒绝策略处理器","layout_left_offset":{"x":-551,"y":-25}},"children":[]}]},{"data":{"id":"cg1cn0lafp40","created":1638096198086,"text":"线程池参数","layout_left_offset":{"x":-395,"y":-58}},"children":[{"data":{"id":"cg1cngngk800","created":1638096233046,"text":"corePoolSize核心线程数","layout_left_offset":{"x":-410,"y":11}},"children":[]},{"data":{"id":"cg1cnnzp0c80","created":1638096249023,"text":"maximumPoolSize最大线程数","layout_left_offset":{"x":-440,"y":5}},"children":[]},{"data":{"id":"cg1cnybaj8w0","created":1638096271492,"text":"threadFactory线程创建工厂","layout_left_offset":{"x":-441,"y":0}},"children":[]},{"data":{"id":"cg1co97rduw0","created":1638096295224,"text":"缓冲队列","layout_left_offset":{"x":-355,"y":-56},"expandState":"expand"},"children":[{"data":{"id":"cg1csmeijj40","created":1638096637387,"text":"1. ArrayBlockingQueue：规定大小的 BlockingQueue，其构造必须指定大小。其所含的对象\n是 FIFO 顺序排序的。\n2. LinkedBlockingQueue：大小不固定的 BlockingQueue，若其构造时指定大小，生成的\nBlockingQueue 有大小限制，不指定大小，其大小有 Integer.MAX_VALUE 来决定。其所含\n的对象是 FIFO 顺序排序的。\n3. PriorityBlockingQueue：类似于 LinkedBlockingQueue，但是其所含对象的排序不是 FIFO，\n而是依据对象的自然顺序或者构造函数的 Comparator 决定。\n4. SynchronizedQueue：特殊的 BlockingQueue，对其的操作必须是放和取交替完成。","layout_left_offset":{"x":-843.0000020861626,"y":-62}},"children":[]}]},{"data":{"id":"cg1coj51b6o0","created":1638096316827,"text":"拒绝策略","layout_left_offset":{"x":-376,"y":-143},"expandState":"expand"},"children":[{"data":{"id":"cg1cs7hj5wg0","created":1638096604917,"text":"1. ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出 RejectedExecutionException异常\n2. ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常\n3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝\n的任务\n4. ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务","layout_left_offset":{"x":-728.0000001788139,"y":-33}},"children":[]}]},{"data":{"id":"cg1cowjhn080","created":1638096345999,"text":"线程最大空闲存活时间","layout_left_offset":{"x":-420,"y":-182}},"children":[]},{"data":{"id":"cg1cretx7ao0","created":1638096542540,"text":"存活时间单位","layout_left_offset":{"x":-406,"y":-184}},"children":[]}]},{"data":{"id":"cg1cszs1l340","created":1638096666503,"text":"创建线程池的方法","layout_left_offset":{"x":-647,"y":-238}},"children":[{"data":{"id":"cg1ctp4syqo0","created":1638096721694,"text":"newSingleThreadExecutor","layout_left_offset":{"x":-377,"y":-24}},"children":[{"data":{"id":"cg1ctu18r7k0","created":1638096732363,"text":"创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的\n线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。","layout_left_offset":{"x":-886.9999998956919,"y":-9}},"children":[]}]},{"data":{"id":"cg1cu8er9q80","created":1638096763655,"text":"newFixedThreadPool","layout_left_offset":{"x":-372,"y":-24}},"children":[{"data":{"id":"cg1cugyss740","created":1638096782281,"text":"创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到\n最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。","layout_left_offset":{"x":-869.0000013262033,"y":-5}},"children":[]}]},{"data":{"id":"cg1culidq680","created":1638096792172,"text":"newCachedThreadPool","layout_left_offset":{"x":-390,"y":-17}},"children":[{"data":{"id":"cg1cuusxn7s0","created":1638096812401,"text":"创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，\n那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。\n此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。","layout_left_offset":{"x":-924.9999986439943,"y":-6}},"children":[]}]},{"data":{"id":"cg1cv7ohxgg0","created":1638096840431,"text":"newScheduledThreadPool","layout_left_offset":{"x":-400,"y":-31}},"children":[{"data":{"id":"cg1cvamkur40","created":1638096846845,"text":"创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。","layout_left_offset":{"x":-800,"y":4}},"children":[]}]}]},{"data":{"id":"cg1cvh2p1i80","created":1638096860881,"text":"创建固定线程池的经验","layout_left_offset":{"x":-618,"y":-270}},"children":[{"data":{"id":"cg1cvvpys400","created":1638096892763,"text":"不是越大越好，太小肯定也不好：","layout_left_offset":{"x":-489,"y":1}},"children":[]},{"data":{"id":"cg1cw0tefxs0","created":1638096903854,"text":"1、如果是 CPU 密集型应用，则线程池大小设置为 N 或 N+1","layout_left_offset":{"x":-607,"y":0}},"children":[]},{"data":{"id":"cg1cw4mkf340","created":1638096912148,"text":"2、如果是 IO 密集型应用，则线程池大小设置为 2N 或 2N+2","layout_left_offset":{"x":-646,"y":6}},"children":[]}]}]}]}]},{"data":{"id":"cfvg6hwmco00","created":1637496828287,"text":"juc","layout_left_offset":{"x":-1362,"y":-623.0000008940697},"expandState":"expand"},"children":[{"data":{"id":"cg1d0dvvoe80","created":1638097245759,"text":"锁机制类","layout_left_offset":{"x":-229,"y":23}},"children":[{"data":{"id":"cg1d3nkz9zc0","created":1638097501960,"text":"Lock, Condition, ReentrantLock, ReadWriteLock,LockSupport","layout_left_offset":{"x":-553,"y":24}},"children":[]},{"data":{"id":"cg1d5ea5td40","created":1638097638443,"text":"1. 使用方式灵活可控\n2. 性能开销小\n3. 锁工具包: java.util.concurrent.locks","layout_left_offset":{"x":-460,"y":14}},"children":[]},{"data":{"id":"cg1d5ohb2ko0","created":1638097660643,"text":"什么是可重入锁？","layout_left_offset":{"x":-306,"y":11}},"children":[{"data":{"id":"cg1d5tb2t7k0","created":1638097671151,"text":"第二次进入时是否阻塞。","layout_left_offset":{"x":-373,"y":-1}},"children":[]}]},{"data":{"id":"cg1d5zxxcgg0","created":1638097685593,"text":"什么是公平锁？","layout_left_offset":{"x":-290,"y":-7}},"children":[{"data":{"id":"cg1d63ugreg0","created":1638097694091,"text":"公平锁意味着排队靠前的优先。\n非公平锁则是都是同样机会","layout_left_offset":{"x":-402,"y":-4}},"children":[]}]},{"data":{"id":"cg1d7ycmwiw0","created":1638097838857,"text":"读写锁","layout_left_offset":{"x":-246,"y":-46}},"children":[{"data":{"id":"cg1d8gjo4880","created":1638097878464,"text":"获取读锁; 共享锁","layout_left_offset":{"x":-293,"y":17}},"children":[]},{"data":{"id":"cg1d8ke17kw0","created":1638097886831,"text":"获取写锁; 独占锁(也排斥读锁)","layout_left_offset":{"x":-352,"y":8}},"children":[]}]},{"data":{"id":"cg1dc0n6l2g0","created":1638098157305,"text":"Condition","layout_left_offset":{"x":-219,"y":-58}},"children":[{"data":{"id":"cg1dc67nty80","created":1638098169427,"text":"通过 Lock.newCondition() 创建","layout_left_offset":{"x":-391,"y":9}},"children":[]}]}]},{"data":{"id":"cg1d0p02m740","created":1638097269957,"text":"原子类","layout_left_offset":{"x":-265,"y":-80}},"children":[{"data":{"id":"cg1d3ur96h40","created":1638097517577,"text":"AtomicInteger, AtomicLong, LongAdder","layout_left_offset":{"x":-450,"y":9}},"children":[{"data":{"id":"cg1dmu89j680","created":1638099005348,"text":"java.util.concurrent.atomic","layout_left_offset":{"x":-522,"y":6}},"children":[]},{"data":{"id":"cg1dn4i1kl40","created":1638099027707,"text":"无锁技术的底层实现原理\nUnsafe API - CompareAndSwap\nCPU 硬件指令支持 - CAS 指令\nValue 的可见性 - volatile 关键字","layout_left_offset":{"x":-572,"y":-3}},"children":[]}]},{"data":{"id":"cg1donav5vc0","created":1638099146996,"text":"核心实现原理","layout_left_offset":{"x":-364,"y":-27}},"children":[{"data":{"id":"cg1dorj3rzs0","created":1638099156201,"text":"1、volatile 保证读写操作都可见（注意不保证原子）；","layout_left_offset":{"x":-494,"y":16}},"children":[]},{"data":{"id":"cg1doungejc0","created":1638099162995,"text":"2、使用 CAS 指令，作为乐观锁实现，通过自旋重试保证写入。","layout_left_offset":{"x":-545.0000006556511,"y":7}},"children":[]}]},{"data":{"id":"cg1dpq2u6y00","created":1638099231405,"text":"锁与无锁","layout_left_offset":{"x":-309,"y":-28}},"children":[{"data":{"id":"cg1dpznzah40","created":1638099252275,"text":"CAS 本质上没有使用锁。\n并发压力跟锁性能的关系：\n1、压力非常小，性能本身要求就不高；\n2、压力一般的情况下，无锁更快，大部分都一次写入；\n3、压力非常大时，自旋导致重试过多，资源消耗很大。","layout_left_offset":{"x":-550.0000071525574,"y":-2}},"children":[]}]},{"data":{"id":"cg1dqvcchw00","created":1638099321228,"text":"LongAdder 对 AtomicLong 的改进","layout_left_offset":{"x":-416,"y":-22}},"children":[{"data":{"id":"cg1drat0m8w0","created":1638099354888,"text":"1、AtomicInteger 和 AtomicLong 里的 value 是所有\n线程竞争读写的热点数据；\n2、将单个 value 拆分成跟线程一样多的数组 Cell[]；\n3、每个线程写自己的 Cell[i]++，最后对数组求和。","layout_left_offset":{"x":-622,"y":-24}},"children":[]}]}]},{"data":{"id":"cg1d2w2dwk00","created":1638097442063,"text":"线程池相关类 Executor ","layout_left_offset":{"x":-423,"y":-113}},"children":[{"data":{"id":"cg1d3z97cx40","created":1638097527370,"text":"Future, Callable, Executor, ExecutorService","layout_left_offset":{"x":-514,"y":3}},"children":[]}]},{"data":{"id":"cg1d31xoabs0","created":1638097454839,"text":"信号量相关","layout_left_offset":{"x":-429,"y":-301}},"children":[{"data":{"id":"cg1d43e4py80","created":1638097536375,"text":" CountDownLatch, CyclicBarrier, Semaphore","layout_left_offset":{"x":-476,"y":5}},"children":[{"data":{"id":"cg1dsamvcu00","created":1638099432881,"text":"CountDownLatch与CyclicBarrier比较","layout_left_offset":{"x":-589,"y":4}},"children":[{"data":{"id":"cg1dsmsshts0","created":1638099459360,"text":"CountDownLatch","layout_left_offset":{"x":-423,"y":-23}},"children":[{"data":{"id":"cg1dt0lwuog0","created":1638099489419,"text":"在主线程里 await 阻塞并做聚合","layout_left_offset":{"x":-409,"y":-23}},"children":[]},{"data":{"id":"cg1dtd3ngtk0","created":1638099516613,"text":"N 个线程执行了countdown，主线程继续","layout_left_offset":{"x":-495,"y":-31}},"children":[]},{"data":{"id":"cg1dtgu0b6g0","created":1638099524737,"text":"主线程里拿到同步点","layout_left_offset":{"x":-415,"y":-39}},"children":[]},{"data":{"id":"cg1dtpvabpk0","created":1638099544405,"text":"基于 AQS 实现，state 为 count，递减到0","layout_left_offset":{"x":-498,"y":-45}},"children":[]},{"data":{"id":"cg1dtv56bco0","created":1638099555887,"text":"不可以复用","layout_left_offset":{"x":-391,"y":-54}},"children":[]}]},{"data":{"id":"cg1dsvi91i00","created":1638099478314,"text":"CyclicBarrier","layout_left_offset":{"x":-440,"y":-34}},"children":[{"data":{"id":"cg1dug72qe00","created":1638099601714,"text":"直接在各个子线程里 await 阻塞，回调聚合","layout_left_offset":{"x":-451,"y":-50}},"children":[]},{"data":{"id":"cg1dul9ihcw0","created":1638099612746,"text":"N 个线程执行了 await 时，N 个线程继续","layout_left_offset":{"x":-462,"y":-58}},"children":[]},{"data":{"id":"cg1duoo01i80","created":1638099620152,"text":"回调被最后到达同步点的线程执行","layout_left_offset":{"x":-456,"y":-62}},"children":[]},{"data":{"id":"cg1dut5z95k0","created":1638099629946,"text":"基于可重入锁 condition.await/signalAll实现","layout_left_offset":{"x":-510,"y":-65}},"children":[]},{"data":{"id":"cg1duz79gtk0","created":1638099643085,"text":"计数为0时重置为 N，可以复用","layout_left_offset":{"x":-427,"y":-67}},"children":[]}]}]}]}]},{"data":{"id":"cg1d3ecz5w80","created":1638097481885,"text":"并发集合类 Collections ","layout_left_offset":{"x":-522,"y":-438}},"children":[{"data":{"id":"cg1d47br5hs0","created":1638097544938,"text":"CopyOnWriteArrayList, ConcurrentMap","layout_left_offset":{"x":-500,"y":-2}},"children":[{"data":{"id":"cg1dxjou61k0","created":1638099844411,"text":"ArrayList","layout_left_offset":{"x":-475,"y":7}},"children":[{"data":{"id":"cg1dxyhkl680","created":1638099876624,"text":"基本特点：基于数组，便于按 index 访问，超过数组需要扩容，扩容成本较高","layout_left_offset":{"x":-632,"y":31}},"children":[]},{"data":{"id":"cg1dy9ge2kg0","created":1638099900497,"text":"用途：大部分情况下操作一组数据都可以用 ArrayList","layout_left_offset":{"x":-495,"y":23}},"children":[]},{"data":{"id":"cg1dyq1jwns0","created":1638099936605,"text":"原理：使用数组模拟列表，默认大小10，扩容 x1.5，newCapacity = oldCapacity +\n(oldCapacity >> 1)","layout_left_offset":{"x":-648,"y":17}},"children":[]},{"data":{"id":"cg1dz3srlo00","created":1638099966549,"text":"安全问题","layout_left_offset":{"x":-243,"y":-3}},"children":[{"data":{"id":"cg1dzd2f0f40","created":1638099986723,"text":"写冲突","layout_left_offset":{"x":-264,"y":4}},"children":[{"data":{"id":"cg1dzlgvy740","created":1638100005012,"text":"两个写，相互操作冲突","layout_left_offset":{"x":-288,"y":2}},"children":[]}]},{"data":{"id":"cg1dzgyj7x40","created":1638099995196,"text":"读写冲突","layout_left_offset":{"x":-256,"y":1}},"children":[{"data":{"id":"cg1dzqd73go0","created":1638100015673,"text":"特别是 iterator 的时候，数据个数变了，拿到了非预期数据或者报错","layout_left_offset":{"x":-550,"y":2}},"children":[]},{"data":{"id":"cg1e023b4540","created":1638100041197,"text":"产生 ConcurrentModificationException","layout_left_offset":{"x":-446,"y":-2}},"children":[]}]},{"data":{"id":"cg1e2t9u3140","created":1638100257093,"text":"解决方法","layout_left_offset":{"x":-242,"y":-10}},"children":[{"data":{"id":"cg1e3386bjc0","created":1638100278760,"text":"ArrayList 的方法都加上 synchronized -> Vector","layout_left_offset":{"x":-496,"y":0}},"children":[]},{"data":{"id":"cg1e38z08q00","created":1638100291267,"text":"Collections.synchronizedList，强制将 List 的操作加上同步","layout_left_offset":{"x":-535,"y":9}},"children":[]},{"data":{"id":"cg1e3gt8vwo0","created":1638100308333,"text":"Arrays.asList，不允许添加删除，但是可以 set 替换元素","layout_left_offset":{"x":-496,"y":5}},"children":[]},{"data":{"id":"cg1e3lsj8c00","created":1638100319173,"text":"Collections.unmodifiableList，不允许修改内容，包括添加删除和 set","layout_left_offset":{"x":-583,"y":10}},"children":[]}]}]}]},{"data":{"id":"cg1e0h3xsbk0","created":1638100073887,"text":"LinkedList","layout_left_offset":{"x":-554,"y":-21}},"children":[{"data":{"id":"cg1e0risvkw0","created":1638100096553,"text":"使用链表实现，无需扩容","layout_left_offset":{"x":-389,"y":2}},"children":[]},{"data":{"id":"cg1e1bu96fc0","created":1638100140781,"text":"用途：不知道容量，插入变动多的情况","layout_left_offset":{"x":-449,"y":-2}},"children":[]},{"data":{"id":"cg1e1fk34ig0","created":1638100148874,"text":"原理：使用双向指针将所有节点连起来","layout_left_offset":{"x":-419,"y":-5}},"children":[]},{"data":{"id":"cg1e1qakr940","created":1638100172243,"text":"写冲突","layout_left_offset":{"x":-258,"y":-36}},"children":[{"data":{"id":"cg1e1uenusg0","created":1638100181197,"text":" 两个写，相互操作冲突","layout_left_offset":{"x":-302,"y":18}},"children":[]},{"data":{"id":"cg1e28jyco80","created":1638100211992,"text":"读，特别是 iterator 的时候，数据个数变了\n，拿到了非预期数据或者报错\n产生 ConcurrentModificationException","layout_left_offset":{"x":-406,"y":8}},"children":[]}]}]},{"data":{"id":"cg1e42t2rmo0","created":1638100356211,"text":"CopyOnWriteArrayList","layout_left_offset":{"x":-542,"y":-86}},"children":[{"data":{"id":"cg1e49plpls0","created":1638100371239,"text":"写加锁，保证不会写混乱","layout_left_offset":{"x":-449,"y":20}},"children":[]},{"data":{"id":"cg1e4dni8jc0","created":1638100379819,"text":"写在一个 Copy 副本上，而不是原始数据上\n（GC young 区用复制，old 区用本区内的移动）","layout_left_offset":{"x":-563,"y":12}},"children":[]},{"data":{"id":"cg1e5rti6hk0","created":1638100489021,"text":"读写分离\n最终一致","layout_left_offset":{"x":-447,"y":3}},"children":[]},{"data":{"id":"cg1e6p0ahb40","created":1638100561265,"text":"插入元素时，在新副本操作，不影响旧引用","layout_left_offset":{"x":-529,"y":-1}},"children":[]},{"data":{"id":"cg1e6uwv0cg0","created":1638100574119,"text":"删除元素时","layout_left_offset":{"x":-360,"y":-15}},"children":[{"data":{"id":"cg1e6zg876o0","created":1638100583997,"text":"删除末尾元素，直接使\n用前N-1个元素创建一个新\n数组。","layout_left_offset":{"x":-412,"y":5}},"children":[]},{"data":{"id":"cg1e741inls0","created":1638100593991,"text":"删除其他位置元素，创\n建新数组，将剩余元素复制\n到新数组。","layout_left_offset":{"x":-402,"y":-5}},"children":[]}]}]},{"data":{"id":"cg1e9s90vfk0","created":1638100803416,"text":"HashMap","layout_left_offset":{"x":-540,"y":-122}},"children":[{"data":{"id":"cg1e9y10a2o0","created":1638100815992,"text":"空间换时间，哈希冲突不大的情况下查找数据性能很高","layout_left_offset":{"x":-510,"y":5}},"children":[]},{"data":{"id":"cg1ea5d6jb40","created":1638100831966,"text":"存放指定 key 的对象，缓存对象","layout_left_offset":{"x":-475,"y":0}},"children":[]},{"data":{"id":"cg1eacxanhc0","created":1638100848419,"text":"使用 hash 原理，存 k-v 数据，初始容量16，扩容x2，负载因子0.75\nJDK8 以后，在链表长度到8 & 数组长度到64时，使用红黑树","layout_left_offset":{"x":-629,"y":-10}},"children":[]},{"data":{"id":"cg1ealovbvk0","created":1638100867501,"text":"安全问题","layout_left_offset":{"x":-271,"y":-38}},"children":[{"data":{"id":"cg1eaquxi940","created":1638100878751,"text":"写冲突","layout_left_offset":{"x":-274,"y":-3}},"children":[]},{"data":{"id":"cg1eauvc8nc0","created":1638100887483,"text":"读写问题，可能会死循环","layout_left_offset":{"x":-322,"y":-10}},"children":[]},{"data":{"id":"cg1eay5sgf40","created":1638100894645,"text":"keys()无序问题","layout_left_offset":{"x":-305,"y":-20}},"children":[]}]}]},{"data":{"id":"cg1eb68sjts0","created":1638100912241,"text":"LinkedHashMap","layout_left_offset":{"x":-584,"y":-191}},"children":[{"data":{"id":"cg1ebom1ms80","created":1638100952225,"text":"继承自 HashMap，对 Entry 集合添加了一个双向链表","layout_left_offset":{"x":-564,"y":4}},"children":[]},{"data":{"id":"cg1ediozt8o0","created":1638101096071,"text":"保证有序，特别是 Java8 stream 操作的 toMap 时使用","layout_left_offset":{"x":-605,"y":4}},"children":[]},{"data":{"id":"cg1edp5cs1k0","created":1638101110121,"text":"同 LinkedList，包括插入顺序和访问顺序","layout_left_offset":{"x":-435,"y":-2}},"children":[]}]},{"data":{"id":"cg1efd404co0","created":1638101240646,"text":"ConcurrentHashMap","layout_left_offset":{"x":-576,"y":-188}},"children":[{"data":{"id":"cg1egofmins0","created":1638101343657,"text":"默认16个 Segment，降低锁粒度。\nconcurrentLevel = 16","layout_left_offset":{"x":-492,"y":-2}},"children":[]},{"data":{"id":"cg1ei9xgadk0","created":1638101468812,"text":"Java 7为实现并行访问，引入了 Segment\n这一结构，实现了分段锁，理论上最大并\n发度与 Segment 个数相等。","layout_left_offset":{"x":-499,"y":-3}},"children":[]},{"data":{"id":"cg1ejtce07s0","created":1638101589438,"text":"Java 8为进一步提高并发性，摒弃了分段\n锁的方案，而是直接使用一个大的数组。","layout_left_offset":{"x":-486,"y":-8}},"children":[]}]},{"data":{"id":"cg1emhdbdq00","created":1638101798465,"text":"ThreadLocal","layout_left_offset":{"x":-544,"y":-193}},"children":[{"data":{"id":"cg1emzdb5xs0","created":1638101837647,"text":"线程本地变量\n场景: 每个线程一个副本\n不改方法签名静默传参\n及时进行清理","layout_left_offset":{"x":-430,"y":-17}},"children":[]}]}]}]}]},{"data":{"id":"cg1eo744ok00","created":1638101932870,"text":"并发使用经验总结","layout_left_offset":{"x":-2150,"y":-1291.000003874302},"expandState":"expand"},"children":[{"data":{"id":"cfvg6jx0sk00","created":1637496832663,"text":"锁","layout_left_offset":{"x":-335,"y":6}},"children":[{"data":{"id":"cg1dezzjrig0","created":1638098390968,"text":"永远只在更新对象的成员变量时加锁","layout_left_offset":{"x":-392,"y":3}},"children":[]},{"data":{"id":"cg1df80tgu80","created":1638098408459,"text":"永远只在访问可变的成员变量时加锁","layout_left_offset":{"x":-404,"y":-2}},"children":[]},{"data":{"id":"cg1dfdh8jb40","created":1638098420336,"text":"永远不在调用其他对象的方法时加锁","layout_left_offset":{"x":-422,"y":-11}},"children":[]}]},{"data":{"id":"cg1dkf9y5vc0","created":1638098816070,"text":"最小使用锁","layout_left_offset":{"x":-357,"y":17}},"children":[{"data":{"id":"cg1dkqlcuqo0","created":1638098840704,"text":"降低锁范围：锁定代码的范围/作用域","layout_left_offset":{"x":-402,"y":-20}},"children":[]},{"data":{"id":"cg1dkwsr9p40","created":1638098854212,"text":"细分锁粒度：讲一个大锁，拆分成多个小锁","layout_left_offset":{"x":-433,"y":-21}},"children":[]}]}]}]},{"data":{"id":"cfvfphaxyhs0","created":1637495494784,"text":"Spring 和 ORM 等框架","layout_mind_offset":{"x":124,"y":-424},"expandState":"collapse"},"children":[{"data":{"id":"cfvg86siwf40","created":1637496960822,"text":"Spring","layout_right_offset":{"x":16,"y":-55},"expandState":"collapse"},"children":[{"data":{"id":"cfvg9b5go5c0","created":1637497048675,"text":"Spring 技术发展"},"children":[]},{"data":{"id":"cfvg9f9rvzc0","created":1637497057643,"text":"Spring 框架设计"},"children":[]},{"data":{"id":"cfvg9ixosuo0","created":1637497065619,"text":"Spring AOP 详解"},"children":[]},{"data":{"id":"cfvg9m5rwwg0","created":1637497072639,"text":"Spring Bean 核心原理"},"children":[]},{"data":{"id":"cfvg9ptbla80","created":1637497080593,"text":"Spring XML 配置原理"},"children":[]},{"data":{"id":"cfvg9t6f4yo0","created":1637497087915,"text":".Spring Messaging 等技术"},"children":[]},{"data":{"id":"cfvga47hohc0","created":1637497111925,"text":"从 Spring 到 Spring Boot"},"children":[]},{"data":{"id":"cfvga5m7gh40","created":1637497114991,"text":"Spring Boot 核心原理"},"children":[]},{"data":{"id":"cfvgabhvvmg0","created":1637497127791,"text":"Spring Boot Starter 详解"},"children":[]}]},{"data":{"id":"cfvg8w5zq000","created":1637497016056,"text":"orm","layout_right_offset":{"x":23,"y":14},"expandState":"collapse"},"children":[{"data":{"id":"cfvgamg1d280","created":1637497151623,"text":"JDBC 与数据库连接池","layout_right_offset":{"x":11,"y":-14}},"children":[]},{"data":{"id":"cfvgas0vogw0","created":1637497163768,"text":"ORM-Hibernate"},"children":[]},{"data":{"id":"cfvgb99i28w0","created":1637497201294,"text":"MyBatis"},"children":[]},{"data":{"id":"cfvgawaorn40","created":1637497173068,"text":"Spring/Spring Boot 集成 ORM/JPA"},"children":[]}]}]},{"data":{"id":"cfvfpvznrew0","created":1637495526754,"text":"MySQL 数据库和 SQL","layout_mind_offset":{"x":171,"y":15},"expandState":"collapse"},"children":[{"data":{"id":"cfvh5e50lds0","created":1637499562832,"text":"MySQL 事务与锁"},"children":[]},{"data":{"id":"cfvh5i17cu00","created":1637499571309,"text":"DB 与 SQL 优化"},"children":[]},{"data":{"id":"cfvh5laqfvk0","created":1637499578415,"text":"常见场景分析"},"children":[]},{"data":{"id":"cfvh68o5piw0","created":1637499629293,"text":"深入数据库原理","layout_right_offset":{"x":-7,"y":-204}},"children":[]},{"data":{"id":"cfvh6wbewmg0","created":1637499680765,"text":"MySQL 配置优化","layout_right_offset":{"x":5,"y":-47}},"children":[]},{"data":{"id":"cfvh70vdknc0","created":1637499690679,"text":"数据库设计优化","layout_right_offset":{"x":10,"y":-37}},"children":[]}]},{"data":{"id":"cfvfq1g7ha80","created":1637495538638,"text":"分库分表","layout_mind_offset":{"x":-195,"y":-27},"expandState":"collapse"},"children":[{"data":{"id":"cfvge1j11og0","created":1637497419549,"text":"为什么要做数据库拆分"},"children":[]},{"data":{"id":"cfvgbu5j4kw0","created":1637497246767,"text":"垂直拆分"},"children":[]},{"data":{"id":"cfvgbyjej5k0","created":1637497256313,"text":"水平拆分"},"children":[]},{"data":{"id":"cfvgc1ww4xk0","created":1637497263659,"text":"相关框架"},"children":[]},{"data":{"id":"cfvgdv8v9gg0","created":1637497405874,"text":"数据迁移"},"children":[]}]},{"data":{"id":"cfvfq5hn19k0","created":1637495547432,"text":"RPC 和微服务","layout_mind_offset":{"x":646,"y":40},"expandState":"collapse"},"children":[{"data":{"id":"cfvggn75wts0","created":1637497623449,"text":"RPC 基本原理","layout_right_offset":{"x":87,"y":-18}},"children":[]},{"data":{"id":"cfvggs9xjmg0","created":1637497634500,"text":"RPC 技术框架","layout_right_offset":{"x":92,"y":-9}},"children":[]},{"data":{"id":"cfvggxu9y7c0","created":1637497646614,"text":"设计一个 RPC","layout_right_offset":{"x":115,"y":6}},"children":[]},{"data":{"id":"cfvghc3ul8o0","created":1637497677668,"text":"Dubbo","layout_right_offset":{"x":101,"y":1}},"children":[{"data":{"id":"cfvghhk3bbk0","created":1637497689534,"text":"介绍"},"children":[]},{"data":{"id":"cfvghkc91yo0","created":1637497695590,"text":"原理"},"children":[]},{"data":{"id":"cfvghn0pgnk0","created":1637497701422,"text":"场景"},"children":[]},{"data":{"id":"cfvghqjs9xs0","created":1637497709106,"text":"最佳实践"},"children":[]},{"data":{"id":"cfvghucoheo0","created":1637497717384,"text":"Dubbo 源码"},"children":[]}]},{"data":{"id":"cfvgis0s97k0","created":1637497790675,"text":"微服务","layout_right_offset":{"x":49,"y":16}},"children":[{"data":{"id":"cfvgju96ew00","created":1637497873900,"text":"治理/配置/注册/元数据中心"},"children":[]},{"data":{"id":"cfvgmaej2x40","created":1637498065781,"text":"注册与发现/集群和路由/过滤和流控"},"children":[]},{"data":{"id":"cfvgmrxvr9k0","created":1637498103956,"text":"微服务最佳实践"},"children":[]}]}]},{"data":{"id":"cfvfq90mgz40","created":1637495555110,"text":"分布式缓存","layout_mind_offset":{"x":-168,"y":18},"expandState":"collapse"},"children":[{"data":{"id":"cfvgspj3nzc0","created":1637498568894,"text":"数据的使用"},"children":[]},{"data":{"id":"cfvgv0qyqvs0","created":1637498750042,"text":"本地缓存"},"children":[]},{"data":{"id":"cfvgv46je3k0","created":1637498757514,"text":"远程缓存"},"children":[]},{"data":{"id":"cfvgv6yg5ww0","created":1637498763556,"text":"缓存策略"},"children":[]},{"data":{"id":"cfvgvbchzkg0","created":1637498773112,"text":"缓存常见问题"},"children":[]},{"data":{"id":"cfvgvkvatyg0","created":1637498793840,"text":"Redis","expandState":"expand"},"children":[{"data":{"id":"cfvgvr54ji80","created":1637498807495,"text":"Redis 基本功能"},"children":[]},{"data":{"id":"cfvgvtvr9c80","created":1637498813459,"text":"Redis 六大使用场景"},"children":[]},{"data":{"id":"cfvgvylp4d40","created":1637498823735,"text":"Redis 的 Java 客户端"},"children":[]},{"data":{"id":"cfvgw27tq7k0","created":1637498831603,"text":"Redis 与 Spring 整合"},"children":[]},{"data":{"id":"cfvgwnmusm80","created":1637498878224,"text":"Redis 高级功能"},"children":[]}]}]},{"data":{"id":"cfvgel6fsjk0","created":1637497462323,"text":"分布式事务","layout_mind_offset":{"x":-156,"y":153},"expandState":"collapse"},"children":[{"data":{"id":"cfvgfvimgy00","created":1637497563192,"text":"分布式事务"},"children":[]},{"data":{"id":"cfvgfy0twl40","created":1637497568646,"text":"XA"},"children":[]},{"data":{"id":"cfvgg1125eg0","created":1637497575190,"text":"BASE"},"children":[]},{"data":{"id":"cfvgg3vmcm00","created":1637497581392,"text":"TCC/AT "},"children":[]},{"data":{"id":"cfvgg7r3jow0","created":1637497589826,"text":"ShardingSphere 对分布式事务的支持"},"children":[]}]},{"data":{"id":"cfvfqd1hzgo0","created":1637495563870,"text":"分布式消息队列","layout_mind_offset":{"x":446,"y":199.00000028312206},"expandState":"collapse"},"children":[{"data":{"id":"cfvgxlo7m7s0","created":1637498952317,"text":"ActiveMQ","layout_left_offset":{"x":-68,"y":-94}},"children":[{"data":{"id":"cfvgxwdzqqg0","created":1637498975643,"text":"通信方式"},"children":[]},{"data":{"id":"cfvgy76m4co0","created":1637498999142,"text":"消息模式与消息协议"},"children":[]},{"data":{"id":"cfvgycx778o0","created":1637499011633,"text":"使用"},"children":[]}]},{"data":{"id":"cfvh1473az40","created":1637499227733,"text":"kafka","layout_left_offset":{"x":-86,"y":-110}},"children":[{"data":{"id":"cfvh192ke1k0","created":1637499238343,"text":"入门"},"children":[]},{"data":{"id":"cfvh1cjsc200","created":1637499245915,"text":"集群"},"children":[]},{"data":{"id":"cfvh1ett9v40","created":1637499250875,"text":"高级特性"},"children":[]}]},{"data":{"id":"cfvh2u7beko0","created":1637499362707,"text":"Rabbitmq","layout_left_offset":{"x":-71,"y":-91}},"children":[]},{"data":{"id":"cfvh32duq4g0","created":1637499380517,"text":"RocketMQ","layout_left_offset":{"x":-74,"y":-76}},"children":[]},{"data":{"id":"cfvh4akyjmg0","created":1637499476725,"text":"Pulsar","layout_left_offset":{"x":-81,"y":-52}},"children":[]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}